---
layout: default
title: "Electoral Consensus"
date: 2017-07-17
use_math: true
---

# Electoral Consensus

## Introduction

This note proposes an overhaul of Ripple consensus that achieves safety with (what I think is) the theoretical minimal connectivity requirements. The protocol is heavily designed after HoneyBadgerBFT, but it modifies a few key parts to make it work in incomplete networks with unknown participants. We call this protocol Electoral Consensus.

Before describing the protocol (which is unfortunately much more complicated than timid validation or conformist validation), we describe some of its characteristics. Loosely speaking, electoral consensus operates each round by electing a commonly agreed upon group of nodes called the **council** in such a way that every node is able to hear a proposal from every node in the council, and every node hears the same proposals, even if an elected councilor is Byzantine. After the council is elected for the round, then each node knows that they see the same information as every other node, and a deterministic algorithm can be employed to then fuse that information to construct the fully-validated ledger. Not every node can be chosen to be a council member; one needs loosely speaking to have reasonably good trust within the network, i.e., a fair number of nodes have you in their UNL. We refer to nodes which are capable of being chosen as councilors by calling them "candidates". Thus this algorithm implicitly segregates validators into reasonably trusted candidates and not as well trusted electors. The way I imagine it, for optimal decentralization one wants as many candidates as possible without making too many of the candidates potentially malicious, so nodes that are honest electors will eventually gain enough trust in the network to become candidates. This gives a more concrete realization of the "layered trust" which is effectively implicit in the current Ripple consensus algorithm as well (untrusted nodes don't have any real sway over consensus under either protocol).

Currently, even with stubborn history, in the presence of $$t_i$$ Byzantine faulty nodes in one's UNL, in order for $$\mathcal{P}_i$$ and $$\mathcal{P}_j$$ to guarantee future-fork safety, they need a UNL overlap of at least $$\min\{t_i,t_j\}+\max\{t_i+\lceil 0.5\vert \mathsf{UNL}_j\vert\rceil,t_j+\lceil 0.5\vert \mathsf{UNL}_i\vert\rceil\}$$. In other words, with a fault tolerance of $$20\%$$, nodes need around $$90\%$$ overlap of UNLs. When the overlap required is this large, one is effecitvely restricted to the current set up of a central completely connected graph with random "leaf validators" listening only to themselves and the central part, at which point the whole concept of being a public blockchain seems to lose most of its meaning. Electoral consensus is designed to minimize the overlap needed to guarantee fork-safety, without resorting to theoretical tools which are dangerous in practice, like forced "message passing" schemes which require nodes to pass along any message they receive, opening up honest nodes to DDoSing.

Each node $$\mathcal{P}_i$$ has a personally designated fault tolerance $$t_i$$, which is the maximal number of faulty nodes allowed in $$UNL_i$$. Electoral consensus gives complete fork safety between two nodes $$\mathcal{P}_i,\mathcal{P}_j$$ whenever their UNL overlap is at least $$t_i+t_j+min\{t_i,t_j\}+1$$. This is the same condition under which Ripple validation guarantees safety against *immediate* forks, but in the case of electoral consensus, this gives safety against *all* forks. In addition, electoral consensus "guarantees" termination even in the midst of total asynchrony, so that every nonfaulty node fully validates a ledger every round; the quotation marks will be explained later because "guarantees termination" is sort of a lie (for several reasons), but it's true in essence.

Despite the excellent safety properties of electoral consensus, it is important to emphasize its drawbacks. The main drawback is performance. Electoral consensus can be run on its own from the start as a complete replacement for Ripple consensus; however, in order to make this work it is probably not sufficient for the councilors to simply broadcast the hash of their transaction set, since it might not be possible to recover the original set if no other nodes proposed an identical set (since e.g. the councilor might crash after broadcasting). Thus one would probably need to propose the entire transaction set; I came up with a way of doing a compression operation based on erasure coding in directed graphs (not described in this note; if you're curious I'd be happy to explain later) that can be used to cut down message size (in such a way that increased overlap allows higher compression), but this might still be too big to get any significant throughput.

Alternatively, electoral consensus can be built on top of Ripple consensus as a validation system. In this case, we already expect the transaction sets to be mostly the same, so it should be unproblematic to just send the hash. The issue with doing things this though is that electoral consensus is significantly slower than Ripple validation or even timid/conformist validation. This will likely add at least several seconds to the time it takes for a ledger to be fully validated. This added latency occurs even when the network is a complete graph. Thus either way, the performance of electoral consensus is relatively poor compared to the current protocols.

In a conversation with David, Stefan, Haoxing, and Joseph, I was tentatively convinced that the latter idea seems more reasonable, so the current note will describe a protocol which operates optimally under the assumption that most nodes can instantly recognize most transaction sets by their hash, so that less communication is involved requesting new transaction sets than propogating each entire (or even compressed portions, using erasure coding) transaction set throughout the network.

## Protocol

We begin by describing three primitives that are needed: binary proposal ($$\mathsf{BPP}$$), binary agreement ($$\mathsf{BA}$$), and reliable broadcast ($$\mathsf{RBC}$$). $$\mathsf{RBB}$$ is used to construct $$\mathsf{BA}$$, and $$\mathsf{BA}$$ and $$\mathsf{RBC}$$ are used in conjunction to construct the overlying multi-valued consensus protocol. Each primitive has a set of properties that we list before describing the protocol itself. Different properties have different requirements on the graph connectivity in order to guarantee fulfillment; we describe the assumptions about the graph needed to fulfill each property individually in the "Proofs" section below.

#### Binary Proposal

Binary proposal allows nodes to share their proposals for binary consensus with each other and "accept" $$0$$, $$1$$, or both, without accidentally picking up a bit that only faulty nodes proposed, with certain guarantees on the agreement of acceptance. More specifically, in $$\mathsf{BPP}$$ each node $$\mathcal{P}_i$$ broadcasts a binary digit "proposal" $$v_i$$, and creates a (private) set $$\mathsf{values}_i$$, with the following properties:

- BPP-Validity: If any honest node $$\mathcal{P}_i$$ adds a bit $$v$$ to $$\mathsf{values}_i$$, then some honest node (possibly not in $$\mathcal{P}_i$$'s UNL) proposed $$v$$.
- BPP-Agreement: If any honest node $$\mathcal{P}_i$$ adds a bit $$v$$ to $$\mathsf{values}_i$$, then every other honest node $$\mathcal{P}_j$$ will eventually add $$v$$ to $$\mathsf{values}_j$$.
- BPP-Progression: Eventually, $$\mathsf{values}_i$$ is nonempty for every honest node $$\mathcal{P}_i$$.

The protocol run by node $$\mathcal{P}_i$$ is as follows:

1. Broadcast $$\mathsf{BPP}(v_i)$$.
2. If we receive $$\mathsf{BPP}(v)$$ from at least $$t_i+1$$ nodes for the bit $$v\neq v_i$$, broadcast $$\mathsf{BPP}(v)$$.
3. If we receive $$\mathsf{BPP}(v)$$ from at least $$\vert\mathsf{UNL}_i\vert-t_i$$ nodes for any bit $$v$$, add $$v$$ to $$\mathsf{values}_i$$.

#### Reliable Broadcast

Reliable broadcast gives nodes a way to broadcast messages to the network, and have the other nodes accept some message, such that one can guarantee that either $$1)$$ no honest node accepts any message, or $$2)$$ every honest node accepts the same message, even if the sender was Byzantine. This limits the damage that a Byzantine potential councilor can do, such that a Byzantine potential councilor is no worse than a crashed potential councilor.

More specifically, we call a node a **candidate** if it has "enough" nodes listening to it in order to "effectively" propogate its messages throughout the network. This is defined formally in the "Proofs" section; it seems to be a reasonably light condition. If $$\mathcal{P}_b$$ is the sender, $$\mathsf{RBC}$$ has the following properties:
- RBC-Validity: If an honest node $$\mathcal{P}_i$$ accepts some message, $$\mathcal{P}_b$$ must have sent that message to some honest node.
- RBC-Agreement: No two honest nodes accept different messages.
- RBC-Termination-Agreement: If any honest node accepts some message, eventually every other honest node will ready that same message.
- RBC-Termination: If the sender is honest and is a candidate, every node will accept the message sent.

$$\mathsf{RBC}$$ effectively proceeds in three steps. Each step has a distinct purpose. In step $$1$$, nodes echo to each other in an attempt to flood the message throughout the network without accidentally picking up a fake message along the way. This maximizes the broadcast capabilities of nodes. In step $$2$$, nodes ready a message if they know no other node will ready a different message in the event the sender was faulty and broadcasted multiple messages. This guarantees agreement on the content of the message among honest nodes. Finally in step 3, nodes accept the message and terminate if they know every other honest node will eventually ready the same message. Since we only care about all nodes knowing what the message was, this is sufficient for our purposes (a true reliable broadcast protocol would actually require nodes to only accept if they know every other node will eventually accept; in a sparse graph this condition becomes needlessly strict. In slightly denser graphs, this protocol does guarantee that if any honest node accepts, eventually all other honest nodes will also accept).

At the start of an RBC instance, the sender $$\mathcal{P}_b$$ broadcasts $$\mathsf{READY}(proposal)$$. $$\mathcal{P}_b$$ accepts its own message when at least $$\vert\mathsf{UNL}_b\vert-t_b$$ nodes in $$\mathsf{UNL}_b$$ broadcast $$\mathsf{READY}(proposal)$$. Every other node $$\mathcal{P}_i$$ operates according to the following protocol.

1. Upon receiving $$\mathsf{READY}(v)$$ directly from $$\mathcal{P}_b$$, or upon receiving $$\mathsf{ECHO}(v)$$ from at least $$t_i+1$$ nodes, if we have not broadcasted an echo message yet, broadcast $$\mathsf{ECHO}(v)$$.
2. Upon receiving $$\mathsf{ECHO}(v)$$ from at least $$\vert\mathsf{UNL}_i\vert-t_i$$ nodes, or upon receiving $$\mathsf{READY}(v)$$ from at least $$t_i+1$$ nodes, if we have not broadcasted a ready message yet, broadcast $$\mathsf{READY}(v)$$.
3. Upon receiving $$\mathsf{READY}(v)$$ from at least $$\vert\mathsf{UNL}_i\vert-t_i$$ nodes, accept $$v$$.

#### Negative Binary Agreement

Negative binary agreement allows nodes to come to consensus on a bit, with an additional property called "BA-Rejection", which is needed to prevent a node from joining the council if some honest node might have terminated without ever having heard of it.

Binary agreement has the following properties:
	- BA-Validity: If an honest node $$\mathcal{P}_i$$ accepts some value, an honest node must have proposed that value.
	- BA-Rejection: If every honest node $$\mathcal{P}_j\in\mathsf{UNL}_i$$ proposes $$0$$ in the UNL of an honest node $$\mathcal{P}_i$$, then no honest node will accept $$1$$.
	- BA-Agreement: No two honest nodes accept different values.
	- BA-Termination: All honest nodes terminate.

BA proceeds in rounds; theoretically it could go on for an arbitrarily large number of rounds (which is of course necessary by FLP), but the expected termination time is four rounds. A node begins on round $$1$$ and broadcasts the message $$\mathsf{PROP}(v_i)$$ with its vote $$v_i$$. On the $$r$$-th round, the node $$\mathcal{P}_i$$ operates according to the following protocol. $$est_i$$ is the value $$\mathcal{P}_i$$ proposes at the start of the round, and $$\mathsf{values}_i$$ starts out empty. We assume nodes can run the algorithm without having proposed a value at the beginning.

1. Begin an instance of $$\mathsf{BPP}$$ proposing value $$est_i$$.
2. If we add a bit $$v$$ to $$\mathsf{values}_i$$ and have not yet broadcasted an aux message: If $$v=0$$, then broadcast $$\mathsf{AUX}(v,r)$$. If $$v=1$$, then only if at least $$\vert\mathsf{UNL}_i\vert-t_i$$ nodes in $$\mathsf{UNL}_i$$ sent out $$\mathsf{PROP}(1)$$ do we broadcast $$\mathsf{AUX}(v,r)$$.
3. Wait until there exists some subset $$S\subseteq\mathsf{UNL}_i$$ such that $$\vert S\vert=\vert\mathsf{UNL}_i\vert-t_i$$, every node in S has sent out an aux message from round $$r$$, and $$\mathsf{values}_i$$ contains the aux value of every node in $$S$$.
4. Let $$s=r\% 2$$ (see also the section on "Regarding the Common Coin"). If $$\vert \mathsf{values}_i\vert=2$$, set $$est_i=s$$ and go back to start round $$r+1$$. If $$\vert \mathsf{values}_i\vert=1$$ and $$s$$ is the value in $$\mathsf{values}_i$$, accept s and terminate the protocol. If $$\vert\mathsf{values}_i\vert=1$$ but $$s$$ is not the value in $$\mathsf{values}_i$$, set $$est_i$$ to the value in $$\mathsf{values}_i$$ and go back to start round $$r+1$$.

#### Multi-valued Consensus

At the start of the protocol, all candidates $$\mathcal{P}_b$$ (or people who think they're candidates when they actually aren't; the only issue that is caused by having non-candidates propose is that it increases the network traffic with no benefits) broadcast $$\mathsf{READY}(h)$$ to begin an instance of $$\mathsf{RBC}$$, where $$h$$ is the hash of $$\mathcal{P}_b$$'s proposal. We use $$\mathsf{RBC}_b$$ to refer to the instance of reliable broadcast involving $$\mathcal{P}_b$$, and similarly $$\mathsf{BA}_b$$ to refer to the instance of binary agreement involving $$\mathcal{P}_b$$. We don't assume it's known to all nodes which nodes are candidates, so there may be $$\mathsf{RBC}$$ and/or $$\mathsf{BA}$$ instances running for nodes which are not actually candidates. We also don't assume that every node knows the existence of any nodes outside of their own UNL, so there could be instances of $$\mathsf{RBC}$$ and $$\mathsf{BA}$$ that are unknown to a node. We leave the local initialization of these instances implicit, so that a node automatically instantiates a new instance as soon as it receives enough messages such that it would take some action if it were running that instance previously.

Every node $$\mathcal{P}_i$$ (including the candidates) then operates according to the following protocol.

1. Upon accepting a hash value from $$\mathsf{RBC}_b$$, check if we know the transaction set that it references. If not, ask our peers if they know to try to find it out. After learning the transaction set which gave rise to the hash, vote $$1$$ in $$\mathsf{BA}_b$$.
2. Once at least R instances of $$\mathsf{BA}$$ have terminated with value $$1$$, broadcast $$\mathsf{ACCEPT}(nodesVotedYes_i)$$, where $$nodesVotedYes_i$$ is the set of nodes $$\mathcal{P}_b$$ for which we have voted $$1$$ in any round of $$\mathsf{BA}_b$$. Thereafter, automatically vote $$0$$ for every other instance of $$\mathsf{BA}$$.
3. Wait until there exists some subset $$S\subseteq\mathsf{UNL}_i$$ such that $$\vert S\vert=\vert\mathsf{UNL}_i\vert-t_i$$, every node in $$S$$ has broadcasted an accept message, and every instance of $$\mathsf{BA}_b$$ for any node $$\mathcal{P}_b$$ in $$nodesVotedYes_j$$ of the accept message of any node $$\mathcal{P}_j$$ in $$S$$. Let $$T$$ be the set of nodes for which $$\mathsf{BA}$$ terminated with value $$1$$.
4. Wait until we have readied some message under reliable broadcast from every node in $$T$$. If we ready a hash that we haven't heard from, ask our peers to try to find it out; by BA-Rejection, there must have been some honest node in our UNL which voted yes on the relevant $$\mathsf{BA}$$ instance, which, due to the criterion for voting yes in step $$1$$, means they must have the transaction set, so we can get the transaction set from them. Because we have the hash, a Byzantine node in our UNL cannot trick us into taking the wrong transaction set.
5. Apply a deterministic algorithm to the proposals we now know of to construct the final block. This deterministic algorithm could be a union, or an intersection, or picking out the transactions with super-majority support, or whatever; as long as all the honest nodes agree on the same algorithm anything works.

## Regarding the Common Coin

The binary agreement protocol by Mostefaouil uses a "common coin", which is basically a threshold signature scheme used as a source of random bits that all honest nodes agree upon, but for which the Byzantine nodes are unable to predict until at least one honest node has requested the coin's value. The neccessity of such a common coin comes from the assumption that the "adversary" (i.e., the entity that is assumed to be controlling all of the Byzantine nodes in order to wreak optimum havok on the network) controls when messages are delivered between honest nodes. Without the coin, the adversary can make messages be delivered in an unoptimal order to prevent the algorithm from ever terminating. The common coin makes it so that the adversary has no way to know when to deliver messages in order to prevent termination.

I personally think the assumption that the adversary can control message delivery times is an absurd think be concerned about in this case. Even if the adversary can predict the value of the common coin, this only allows the adversary to block termination and is not a threat to fork-safety. And if the adversary chooses when messages are delivered between honest nodes, then it can just as easily prevent those messages from ever being delivered, which would be a far more effective way of preventing termination anyway. Thus the common coin seems pointless to me. Further, computing the value of the common coin from what I can tell is a significant part of the latency cost of Mostefaouil's original algorithm, so avoiding the use of a common coin should give a good performance boost.

Regardless, we still need a way to get coin values for each round which are agreed upon by all honest nodes. An alternative is to simply use the round number mod $$2$$. This has the benefit of being very simple, and (since round numbers start at $$1$$) if all honest nodes propose $$1$$ then consensus will always terminate on the first round. Since the multi-valued algorithm needs to wait until a certain number of $$\mathsf{BA}$$ have terminated on $$1$$ before nodes can start voting $$0$$, this speeds up the time it takes for nodes to move onto the next step. It also biases the council size towards being larger, which seems like a good thing.

I may be in the minority though in thinking that letting the adversary control network delays to prevent termination is not an issue. If this is the case it would be good to have a common coin protocol anyway. Unfortunately, my aversion to common coins is not only based on the fact that I think they're unneccessary, but also I have no idea if it's possible to make a common coin protocol in the relevant domain (i.e., when there can be an arbitrary number of Byzantine nodes so long as the number of Byzantine nodes in any honest node's UNL is bounded). Traditional common coins work by using a threshold signature as a source of random bits. However, it's unclear to me how to make threshold schemes work with an unbounded number of faults. A less-than-satisfactory option that nonetheless might work would be to only give the "core" validators threshold shares, under the assumption that fewer than $$f$$ core validators are faulty for some prescribed $$f$$, and every honest node has at least $$2f+1$$ core validators in their UNL. Then we could just do a regular threshold signature algorithm with no trouble.

If anyone has some other ideas for how a common coin could work more satisfactorily, I'd like to hear it, if for nothing other than to know that it's possible.

## Proofs

Having gotten through all the protocols, I should now explain why the above protocols work. The easiest way for me as a mathematician to communicate this is through proofs. Thus I will prove that the above primitives satisfy all the properties I claimed, and then explain why multi-valued consensus works using the properties we've proven.

For total explicitness, we state the exact graph properties needed for each individual property to work. Graph properties typically come in two types: "blocking properties" and "flow properties". Blocking properties come into play when we want two situations to be mutually exclusive (they *block* each other). For instance, if one node can terminate on output $$A$$, then a blocking property comes into play in order to prevent any other node from terminating on $$B\neq A$$. Flow properties on the other hand come into play when we want something to spread throughout the network, so that for instance if one node sees a lot of support for $$A$$, then eventually every other node will also see a lot of support for $$A$$. Abstractly, if $$\mathcal{P}_i,\mathcal{P}_j$$ are nodes and $$A$$ and $$B$$ are contradictory "termination states" that each node can be in, then blocking properties are used to prove statements of the form "if $$A_i$$ right now, then not $$B_j$$ right now", while flow properties are used to prove statements of the form "if $$A_i$$ right now, then $$A_j$$ eventually".

Generally speaking, blocking properties are "local" (i.e., only involve direct overlaps) which makes it easy to state necessary and sufficient conditions under which they're satisfied, but the conditions are typically relatively strict. In contrast, flow properties are usually relatively weak and easy to satisfy in general, but are difficult to describe because they involve more "global" factors. Typically, there is some easily-stated sufficient condition under which a flow property is trivially satisfied, but these sufficient conditions are much stricter than actually needed. For simplicity, I avoid stating the flow properties in their most general form and only prove the statements that involve flow properties using simpler sufficient-but-not-neccessary conditions (typically the "second simplest" condition; I think this strikes a good balance between weakness and simplicity).

#### Binary Proposal Proofs

Proposition 1: (BPP-Validity) Suppose for all honest nodes $$\mathcal{P}_i$$, $$\vert\mathsf{UNL}_i\vert\geqslant 2t_i+1$$. Then if an honest node accepts a bit $$v$$ under binary proposal, there must have been some honest node which proposed $$v$$.
Proof. Suppose an honest node $$\mathcal{P}_i$$ accepts $$v$$. Then by the predicate for acceptance in step $$3$$, at least $$\vert\mathsf{UNL}_i\vert-t_i$$ nodes in $$\mathsf{UNL}_i$$ must have broadcasted $$\mathsf{BPP}(v)$$, and by hypothesis $$\vert\mathsf{UNL}_i\vert-t_i>t_i$$, so some honest node in $$\mathsf{UNL}_i$$ must have broadcasted $$\mathsf{BPP}(v)$$. But an honest node $$\mathcal{P}_j$$ only broadcasts $$\mathsf{BPP}(v)$$ if either it proposed $$v$$ or there were at least $$t_j+1$$ nodes in $$\mathsf{UNL}_j$$ which broadcasted $$\mathsf{BPP}(v)$$ before $$\mathcal{P}_j$$, i.e., if an honest node $$\mathcal{P}_j$$ broadcasts $$\mathsf{BPP}(v)$$, either it proposed $$v$$ or there must have been some honest node in $$\mathsf{UNL}_j$$ which broadcasted $$\mathsf{BPP}(v)$$ before $$\mathcal{P}_j$$. But since there are only a finite number of nodes, by infinite descent there must have been some honest node $$\mathcal{P}_k$$ such that no honest node in $$\mathsf{UNL}_k$$ broadcasted $$\mathsf{BPP}(v)$$ before $$\mathcal{P}_k$$. Thus $$\mathcal{P}_k$$ must have proposed $$v$$, so $$v$$ was proposed by an honest node as claimed.

Lemma 2: Suppose $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant t_i+t_k+\min\{t_i,t_k\}+1$$ for some honest node $$\mathcal{P}_k$$. Then if $$\mathcal{P}_i$$ accepts a bit $$v$$ under binary proposal, eventually $$\mathcal{P}_k$$ will broadcast $$\mathsf{BPP}(v)$$.
Proof. Let $$\mathcal{P}_k$$ be any honest node. By definition there are at most $$\min\{t_i,t_k\}$$ nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_k$$ which are faulty. Thus by hypothesis there are at least $$t_i+t_k+1$$ honest nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_k$$. By the predicate for acceptance, at most $$t_i$$ honest nodes in $$\mathsf{UNL}_i$$ didn't broadcast $$\mathsf{BPP}(v)$$, so at least $$t_k+1$$ honest nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_k$$ must have broadcasted $$\mathsf{BPP}(v)$$. Thus by the predicate in step $$2$$, $$\mathcal{P}_k$$ will broadcast $$\mathsf{BPP}(v)$$.

Corollary 3: (BPP-Agreement-1) Let $$\mathcal{P}_j$$ be any honest node such that $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant t_i+t_k+\min\{t_i,t_k\}+1$$ for every $$\mathcal{P}_k\in \mathsf{UNL}_j$$. Then if $$\mathcal{P}_i$$ accepts and value $$v$$, eventually $$\mathcal{P}_j$$ will also accept $$v$$.
Proof. By lemma 2, eventually every honest node in $$\mathsf{UNL}_j$$ will broadcast $$\mathsf{BPP}(v)$$. Since there are at least $$\vert\mathsf{UNL}_j\vert - t_j$$ honest nodes in $$\mathsf{UNL}_j$$, $$\mathcal{P}_j$$ eventually satisfies the predicate in step $$3$$ and accepts $$v$$.

Lemma 4: If all honest nodes in $$\mathsf{UNL}_i$$ broadcast $$\mathsf{BPP}(v)$$ and $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant t_k+\min\{t_i,t_k\}+1$$ for some honest node $$\mathcal{P}_k$$, then eventually $$\mathcal{P}_k$$ will broadcast $$\mathsf{BPP}(v)$$.
Proof. By hypothesis there are at least $$t_k+1$$ honest nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_k$$, so by the predicate in step $$2$$, $$\mathcal{P}_k$$ will broadcast $$\mathsf{BPP}(v)$$.

Corollary 5: (BPP-Agreement-2) Suppose $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant t_i+t_k+\min\{t_i,t_k\}+1$$ for every honest node $$\mathcal{P}_k\in \mathsf{UNL}_i$$. Let $$\mathcal{P}_j$$ be any honest node such that $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant t_k+\min\{t_i,t_k\}+1$$ for every $$\mathcal{P}_k\in \mathsf{UNL}_j$$. Then if $$\mathcal{P}_i$$ accepts any value $$v$$, eventually $$\mathcal{P}_j$$ will also accept $$v$$.
Proof. By lemma 2, eventually every honest node in $$\mathsf{UNL}_i$$ will broadcast $$\mathsf{BPP}(v)$$. By lemma 4, thus every honest node $$\mathsf{UNL}_j$$ will broadcast $$\mathsf{BPP}(v)$$; the same argument as corollary 3 thus completes the proof.

Definition 6: Given two nodes $$\mathcal{P}_i,\mathcal{P}_j$$, $$\mathcal{P}_i$$ **terminates** $$\mathcal{P}_j$$ if whenever $$\mathcal{P}_i$$ accepts a value, $$\mathcal{P}_j$$ also accepts that value eventually. Clearly termination is a transitive relation on nodes.

Corollaries 3 and 5 give sufficient conditions under which $$\mathcal{P}_i$$ terminates $$\mathcal{P}_j$$. Since this is a flow property, though, neither of the hypotheses of these corollaries is necessary. The actual necessary-and-sufficient condition is much more complicated and I don't fully understand it.

Definition 7: A node $$\mathcal{P}_i$$ is called a **terminator** if $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant \vert \frac\mathsf{UNL}_i\vert+t_i}{2}+t_k+1$$ for every honest node $$\mathcal{P}_k\in\mathsf{UNL}_i$$.

Lemma 8: (BPP-Progression-1) If $$\mathcal{P}_i$$ is a terminator, then eventually $$\mathsf{values}_i$$ is nonempty.
Proof. There are at least $$\vert\mathsf{UNL}_i\vert-t_i$$ honest nodes in $$\mathsf{UNL}_i$$. Since honest nodes can only propose a single value, and only two values (i.e., $$0$$ and $$1$$) can be proposed, there must be some value $$v$$ that was proposed by at least $$\frac\mathsf{UNL}_i\vert-t_i}{2}$$ nodes in $$\mathsf{UNL}_i$$. Thus by hypothesis, there are at least $$t_k+1$$ honest nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_k$$ for every honest node $$\mathcal{P}_k\in\mathsf{UNL}_i$$. Thus every honest node in $$\mathsf{UNL}_i$$ eventually broadcasts $$\mathsf{BPP}(v)$$, so $$\mathcal{P}_i$$ eventually satisfies the predicate for step $$3$$ and accepts $$v$$.

Corollary 9: (BPP-Progression-2) If $$\mathcal{P}_i$$ is a terminator and $$\mathcal{P}_j$$ is an honest node such that $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant t_k+\min\{t_i,t_k\}+1$$ for every $$\mathcal{P}_k\in \mathsf{UNL}_j$$, then eventually $$\mathsf{values}_j$$ is nonempty.
Proof. The overlap condition on being a terminator is strictly stronger than the hypothesis of corollary 5, so this follows immediately from that proof.

#### Reliable Broadcast Proofs

Proposition 10: (RBC-Validity) Suppose for all honest nodes $$\mathcal{P}_i$$, $$\vert\mathsf{UNL}_i\vert\geqslant 2t_i+1$$. Then if an honest node accepts a message $$v$$ under reliable broadcast, the sender must have broadcasted $$v$$ to some honest node. In fact, if any honest node either echoes or readies a message, then the sender must have broadcast that message to some honest node.
Proof. The proof of this is basically the same as the proof of proposition 1.

Lemma 11: Suppose $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_j\vert\geqslant t_i+t_j+\min\{t_i,t_j\}+1$$. Then if $$\mathcal{P}_i$$ readies a message $$v$$ under reliable broadcast, then $$\mathcal{P}_j$$ cannot ready a message $$w\neq v$$.
Proof. Let $$\mathcal{P}_j$$ be any honest node. By definition there are at most $$\min\{t_i,t_j\}$$ nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_j$$ which are faulty. Thus by hypothesis there are at least $$t_i+t_j+1$$ honest nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_j$$. By the predicate for accepting a message, at most $$t_i$$ honest nodes in $$\mathsf{UNL}_i$$ didn't broadcast $$\mathsf{READY}(v)$$, so at least $$t_j+1$$ honest nodes in $$\mathsf{UNL}_i\cap\mathsf{UNL}_j$$ must have broadcasted $$\mathsf{READY}(v)$$. Since honest nodes can only ready a single value, at most $$\vert\mathsf{UNL}_j\vert-t_j-1$$ nodes in $$\mathsf{UNL}_j$$ can broadcast $$\mathsf{READY}(w)$$ to $$\mathcal{P}_j$$, so $$\mathcal{P}_j$$ can never satisfy the predicate in step $$3$$ and accept $$w$$.

Corollary 12: (BPP-Agreement) Suppose $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_j\vert\geqslant t_i+t_j+\min\{t_i,t_j\}+1$$, $$\vert\mathsf{UNL}_i\vert\geqslant 2t_i+1$$, and $$\vert\mathsf{UNL}_j\vert\geqslant 2t_j+1$$. Then if $$\mathcal{P}_i$$ accepts a message $$v$$ under reliable broadcast, then $$\mathcal{P}_j$$ cannot accept a message $$w\neq v$$.
Proof. Since $$\vert\mathsf{UNL}_i\vert\geqslant 2t_i+1$$ by hypothesis, the criterion for $$\mathcal{P}_i$$ to ready is weaker than the criterion to accept, so $$\mathcal{P}_i$$ will also ready if it accepts. Thus by lemma 11, $$\mathcal{P}_j$$ cannot ready a message $$w\neq v$$. But since $$\vert\mathsf{UNL}_j\vert\geqslant 2t_j+1$$, this also implies that $$\mathcal{P}_j$$ cannot accept $$w$$.

Proposition 13: (RBC-Termination-Agreement) Suppose $$\vert\mathsf{UNL}_i\vert\geqslant 2t_i+1$$, and let $$\mathcal{P}_j$$ be any honest node such that $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_j\vert\geqslant t_i+t_j+\min\{t_i,t_j\}+1$$. Then if $$\mathcal{P}_i$$ accepts any message $$v$$, then $$\mathcal{P}_j$$ will eventually ready $$v$$.
Proof. By hypothesis that $$\vert\mathsf{UNL}_i\vert\geqslant 2t_i+1$$, if $$\mathcal{P}_i$$ accepts then it will also ready. By lemma 11 and our hypotheses, if $$\mathcal{P}_i$$ readies a message, then $$\mathcal{P}_j$$ cannot have readied any other message $$w\neq v$$. Thus in particular $$\mathcal{P}_j$$ cannot be "blocked" from readying a $$v$$ due to having already readied a different message. By the predicate for acceptance, at least $$\vert\mathsf{UNL}_i\vert-t_i$$ nodes in $$\mathsf{UNL}_i$$ must have readied $$v$$. By the same argument as e.g., lemma 2, eventually $$\mathcal{P}_j$$ will receive ready messages for $$v$$ from at least $$t_j+1$$ honest nodes in $$\mathsf{UNL}_j$$, so $$\mathcal{P}_j$$ will eventually ready $$v$$.

Corollary 14: Suppose $$\vert\mathsf{UNL}_i\vert\geqslant 2t_i+1$$, and let $$\mathcal{P}_j$$ be any honest node such that $$\vert\mathsf{UNL}_i\cap\mathsf{UNL}_k\vert\geqslant t_i+t_k+\min\{t_i,t_k\}+1$$ for every honest node $$\mathcal{P}_k\in\mathsf{UNL}_j$$. Then if $$\mathcal{P}_i$$ accepts any message $$v$$, then $$\mathcal{P}_j$$ will eventually also accept $$v$$.
Proof. By proposition 13 and our hypotheses, eventually every honest node in $$\mathsf{UNL}_j$$ will ready $$v$$, so eventually $$\mathcal{P}_j$$ will see enough ready messages to accept $$v$$.

Definition 15: Given two nodes $$\mathcal{P}_i,\mathcal{P}_j$$, $$\mathcal{P}_i$$ **propagates** $$\mathcal{P}_j$$ if whenever $$\mathcal{P}_i$$ accepts a message from some sender, $$\mathcal{P}_j$$ also accepts that message eventually, even if the sender is Byzantine. Clearly propagation is a transitive relation on nodes.

I don't think terminating and propagating are mutually implicative in either direction; propagating can be more difficult because of the fact that nodes can be blocked from readying the desired message (if the sender is Byzantine), but I think it can also be easier because of the fact that in contrast with BPP where the proposals can be totally unrestricted, in RBC the "proposals" (i.e., the first message echoed) of nodes are restricted, even in the case where the sender is Byzantine (since no sender neccessarily broadcasts to every node).

Definition 16: A node $$\mathcal{P}_b$$ is a **candidate** for a set of nodes $$X\subseteq V_G$$ if whenever $$\mathcal{P}_b$$ is honest, every node in $$X$$ eventually accepts its message.

Lemma 17: If a node $$\mathcal{P}_b$$ is a candidate for a set $$X\subseteq V_G$$, then $$\mathcal{P}_b$$ is a candidate for the set $$X'$$ of all nodes terminated by some node in $$X$$.
Proof. By proposition 10, if $$\mathcal{P}_b$$ is honest then honest nodes can only ready the (single) message broadcasted by $$\mathcal{P}_b$$. Thus no "blocking" of readies occurs, so the flow of readies is identical to the flow of BPP. Thus the claim follows trivially by the definitions of termination and candidate.

Lemma 18: If $$\mathcal{P}_b$$ is an honest sender and $$\vert\mathsf{BUNL}_b\cap\mathsf{UNL}_k\vert\geqslant 2t_k+1$$ for all $$\mathcal{P}_k\in\mathsf{UNL}_i\setminus\mathsf{BUNL}_b$$ for some honest node $$\mathcal{P}_i$$, then $$\mathcal{P}_i$$ will eventually ready the message $$\mathcal{P}_b$$ sends.
Proof. Since the sender is honest, by proposition 10, no node can ever echo a message that $$\mathcal{P}_b$$ did not send; in particular, no node can be blocked from echoing. Thus all honest nodes in $$\mathsf{BUNL}_b$$ will echo the message $$\mathcal{P}_b$$ sends. If $$\mathcal{P}_k\in\mathsf{UNL}_i\setminus\mathsf{BUNL}_b$$, then by hypothesis there are at least $$t_k+1$$ honest nodes in $$\mathsf{BUNL}_b\cap\mathsf{UNL}_k$$, so eventually $$\mathcal{P}_k$$ will also echo the message. Thus every honest node in $$\mathsf{UNL}_i$$ echos the message, so eventually $$\mathcal{P}_i$$ will ready the message.

Corollary 19: (BPP-Termination) Let $$\mathsf{UNL}_i^2$$ denote the set of all nodes in the UNL of some node in $$\mathsf{UNL}_i$$. If $$\vert\mathsf{BUNL}_b\cap\mathsf{UNL}_k\vert\geqslant 2t_k+1$$ for all honest nodes $$\mathcal{P}_k\in\mathsf{UNL}_i^2\setminus\mathsf{BUNL}_b$$, then $$\mathcal{P}_b$$ is a candidate for $$\{\mathcal{P}_i\}$$.
Proof. Suppose $$\mathcal{P}_b$$ is honest. By definition of $$\mathsf{UNL}_i^2$$ and lemma 18, eventually every honest node in $$\mathsf{UNL}_i$$ will ready the message $$\mathcal{P}_b$$ sends. Thus $$\mathcal{P}_i$$ will eventually see enough readies to accept.

#### Binary Agreement Proofs

TBC
