---
layout: default
title: "HoneyBadger with Constant Expected Time"
date: 2017-09-11
use_math: true
---

# HoneyBadger with Constant Expected Time

The HoneyBadger protocol uses a parallel collection of asynchronous binary consensus instances indexed over the set of nodes in order to construct an agreed-upon set of nodes $$C$$ with $$\vert C\vert\geqslant n-f$$ and such that every node in $$C$$ had its proposal (i.e., its reliable broadcast) accepted by the honest nodes. Unfortunately, although each individual binary consensus instance completes in constant expected time, since you need to wait until $$n$$ consensus instances terminate, the expected latency for HoneyBadger grows logarithmically with $$n$$ (to understand this intuitively, imagine $$n$$ coins being flipped until each one has landed on heads at least once; we would expect that with each flip about half of the coins land on heads, so the time until all of them have landed on heads at least once grows logarithmically like the height of a binary tree).

This note proposes a modification to the algorithm that makes the expected latency of HoneyBadger itself constant. On a high level, the modification works by replacing "agree upon a subset $$C$$" with "have each node $$\mathcal{P}_i$$ pick a subset $$C_i$$ that the other nodes can verify is a suitable set, then agree upon a single node $$\mathcal{P}_j$$ such that $$C_j$$ is a suitable set and set $$C=C_j$$". By selecting a random agreed-upon ordering of the nodes, one only needs to wait until there is some node whose associated binary consensus instance has terminated on $$1$$ and every node ordered below it has terminated on $$0$$, then we can choose that node even before the other instances have terminated. The protocol makes it so that every honest node's chosen set is suitable, so that a randomly chosen node has a suitable set with probability $$(n-f)/n>2/3$$. Thus the expected number of instances that need to terminate is at most a constant less than $$1.5$$.

The protocol is somewhat intricate, so for easier digestion we break it up into two parts: Deciding on one's personal subset, and deciding on whose personal subset to use.

## The Protocol

As usual, the protocol begins with a preceding phase where each node sends out a reliable broadcast with its proposal. The protocol below outputs a set of nodes $$C$$ such that $$\vert C\vert\geqslant n-f$$, every node in $$C$$ has its reliable broadcast accepted, and all nodes agree on $$C$$.

#### Choosing the Personal Subsets

The protocol for deciding on one's personal subset involves two parts. First the node $$\mathcal{P}_i$$ node comes up with a "naive estimate" $$B_i$$ such that $$\vert B_i\vert\geqslant n-f$$, $$\mathcal{P}_i$$ knows that it will eventually accept reliable broadcast from every node in $$B_i$$, and the intersection of the $$B_i$$ across all honest nodes has cardinality at least $$n-f$$. The second part involves culling $$B_i$$ down to construct $$C_i$$ such that $$C_i\subseteq B_j$$ for at least $$n-2f$$ honest nodes $$\mathcal{P}_j$$. This gives the "verifiability" requirement that allows other honest nodes to know when $$C_i$$ is a suitable set, since $$C_i\subseteq B_i$$ implies that $$\mathcal{P}_j$$ knows that it will eventually accept reliable broadcast from every node in $$C_i$$.

1. Upon accepting reliable broadcast from $$\mathcal{P}_j$$, the node $$\mathcal{P}_i$$ multicasts $$VOTE(1,j)$$.
2. Upon receiving at least $$f+1$$ $$VOTE(v,k)$$ messages for a binary value $$v$$, $$\mathcal{P}_i$$ multicasts $$VOTE(v,k)$$ if it hasn't already.
3. Upon receiving at least $$n-f$$ $$VOTE(v,k)$$ messages for a binary value $$v$$, $$\mathcal{P}_i$$ adds $$v$$ to the set $$\mathsf{bin\_values}_k$$. If $$\mathsf{bin\_values}_k$$ was previously empty, then $$\mathcal{P}_i$$ multicasts $$AUX(v,k)$$.
4. Upon receiving $$AUX(\_,k)$$ messages from some set of nodes $$S_k$$ such that $$\vert S_k\vert\geqslant n-f$$ and for any binary value $$v$$ for which $$AUX(v,k)$$ was sent by some node in $$S_k$$ we have $$v\in\mathsf{bin\_values}_k$$, then $$\mathcal{P}_i$$ adds $$\mathcal{P}_k$$ to the set $$A_i$$. If $$1\in\mathsf{bin\_values}_k$$, then $$\mathcal{P}_i$$ adds $$\mathcal{P}_k$$ to the set $$B_i$$. If in addition $$0\notin\mathsf{bin\_values}_k$$ (i.e., if $$\mathsf{bin\_values}_k=\{1\}$$), then $$\mathcal{P}_i$$ adds $$\mathcal{P}_k$$ to the set $$B_i'$$.
5. Once $$\vert B_i'\vert\geqslant n-f$$, $$\mathcal{P}_i$$ votes $$0$$ in every other instance.
6. Once $$\vert A_i\vert=n$$, $$\mathcal{P}_i$$ multicasts $$INIT(B_i)$$.
7. Upon receiving $$INIT(B_j)$$ from $$\mathcal{P}_j$$, $$\mathcal{P}_i$$ checks if $$\vert B_i\cap B_j\vert\geqslant n-f$$; if so, $$\mathcal{P}_i$$ sends $$CONFIRM(B_i\cap B_j)$$ to $$\mathcal{P}_j$$.
8. Upon receiving $$CONFIM(\_)$$ messages from a set $$T$$ of nodes, with $$\vert T\vert\geqslant n-f$$ and $$\vert C_T\vert\geqslant n-f$$, where $$\bigcap_{\mathcal{P}_k\in T} (B_i\cap B_k)$$, then $$\mathcal{P}_i$$ outputs $$C_i:=C_T$$.

Since there are at least $$n-f$$ correct nodes and a reliable broadcast sent by a correct node is eventually accepted by all correct nodes, step 5 does not endlessly halt the protocol. The first four lines are effectively the first round of Mostefaoui's binary consensus protocol (with one consensus round associated to each node) with the value of the common coin set determinstically to $$1$$. Thus the fact that step 6 does not halt comes from the termination-agreement of reliable broadcast and step 5 (which together guarantee that every node will eventually vote in every consensus instance) and the termination property of Mostefaoui's algorithm (which guarantees that if every node votes then the algorithm will eventually make forward progress). Further, by the justification property of Mostefaoui's algorithm, any node added to $$B_i$$ must have had its reliable broadcast accepted by some honest node, so eventually $$\mathcal{P}_i$$ will accept its reliable broadcast.

Lines 7-8 rely on the fact that from the way we wait in step 5, there are at least $$n-f$$ voting instances for which some honest node saw $$n-f$$ aux messages for $$1$$; thus at most $$n-f-1$$ nodes can send out an aux message for $$0$$, so no other honest node can get past step 4 in that instance without adding $$1$$ to its binary values, so that every honest node adds those $$n-f$$ nodes to its personal $$B$$ set. Thus the intersection of all the honest nodes' $$B$$ sets has size at least $$n-f$$, so as soon as a node receives confirm messages back from all the honest nodes, it can satisfy the predicate in step 8 and terminate. Further, after terminating, there is a subset $$T'\subset T$$ where every node in $$T'$$ is honest and $$\vert T'\vert\geqslant \vert T\vert - f\geqslant n-2f$$. By the computation in step 8, $$C_i\subseteq B_j$$ for every node $$\mathcal{P}_j\in T'$$. Thus $$C_i\subseteq B_j$$ for at least $$n-2f$$ honest nodes $$\mathcal{P}_j$$.

Careful inspection of the protocol gives that the total number of asynchronous communication rounds in the worst case is $$8$$: $$3$$ to get past step 5, $$3$$ to get past step 6, and $$2$$ in steps 7-8.

#### Choosing the Person

Now we present the protocol that decides on whose personal $$C$$ set to use.

1. The nodes first construct a common random value which is used to pseudo-randomly determine an ordering for the nodes. This could be just a determinstic function of the consensus round id, but it might be good to set up a cooperative protocol using threshold signatures so that malicious nodes can't predict when they will create maximum chaos by acting up.
2. $$\mathcal{P}_i$$ multicasts $$INITFIN(C_i)$$.
3. Upon receiving $$INITFIN(C_j)$$ from $$\mathcal{P}_j$$, if $$\vert C_j\vert\geqslant n-f$$ and $$C_j\subseteq B_i$$, $$\mathcal{P}_i$$ multicasts $$ECHOFIN(C_j,j)$$.
4. Upon receiving $$ECHOFIN(C_k,k)$$ from at least $$f+1$$ nodes, $$\mathcal{P}_i$$ multicasts $$ECHOFIN(C_k,k)$$ if it hasn't already sent out a $$ECHOFIN(\_,k)$$ message.
5. Upon receiving $$ECHOFIN(C_k,k)$$ from at least $$n-f$$ nodes or $$READYFIN(C_k,k)$$ from at least $$f+1$$ nodes, $$\mathcal{P}_i$$ multicasts $$READYFIN(C_k,k)$$ if it hasn't already sent out a $$READYFIN(\_,k)$$ message.
6. Upon receiving $$READYFIN(C_k,k)$$ from at least $$n-f$$ nodes, $$\mathcal{P}_i$$ votes $$1$$ in a Mostefaoui binary consensus instance pertaining to $$\mathcal{P}_j$$. The coin value for the first round of these ABC instances is set determinstically to $$1$$, but for all the other rounds it uses an actual common coin (setting the first coin to $$1$$ is not necessary for correctness, but it speeds up the expected termination time by around $$1.5x$$ in the worst case and $$6x$$ in the best case, and removes some communication).
7. After $$n-f$$ ABC instances terminate with $$1$$, $$\mathcal{P}_i$$ votes $$0$$ in every other instance.
8. $$\mathcal{P}_i$$ waits until there is some value $$k$$ such that in the random ordering from step $$4$$, all the ABC instances for $$\mathcal{P}_1,...,\mathcal{P}_{k-1}$$ have terminated with $$0$$ and the ABC instance for $$\mathcal{P}_k$$ has terminated with $$1$$. Then $$\mathcal{P}_i$$ waits until it has accepted the nodelist $$C_k$$ in the Bracha broadcast from $$\mathcal{P}_k$$, after which the output is $$C:=C_k$$.

Note that steps 1-5 are effectively just Bracha broadcast with a validation predicate for accepting an init message. The validation predicate ensures that if any honest node votes $$1$$ in a binary consensus instance associated with a node $$\mathcal{P}_k$$, then $$\vert C_k\vert\geqslant n-f$$ and there must have been some honest node $$\mathcal{P}_j$$ such that $$C_k\subseteq B_j$$, which implies that every node in $$C_k$$ will eventually have its proposal accepted by all the honest nodes. Further, since every honest node has $$f+1$$ nodes whose $$B$$ set contains its $$C$$ set, eventually every Bracha broadcast from an honest node will be accepted by all the honest nodes, since those $$f+1$$ nodes will echo to every other honest node, and by step 4 every honest node will thus eventually echo the message. Thus step 7 does not endlessly halt.

By the predicate in step 7, there is a set $$S$$ with $$\vert S\vert\geqslant n-f$$ such that the associated ABC instance for every node in $$S$$ terminates on $$1$$. By a difficult computation, one finds that the expected value for the index of the first node in a random ordering whose binary consensus terminates on $$1$$ is $$f/(n-f+1)$$, which is $$O(1)$$ when $$f$$ is $$O(n)$$. Thus we only need to wait for $$O(1)$$ binary consensus instances to terminate, giving a constant latency.

This phase uses at most $$3$$ asynchronous communication rounds for the reliable broadcasts. Getting past step 7, with the deterministic coin in the first round, uses at most $$3$$ communication rounds. The binary consensus instances use at most $$4$$ communication rounds per iteration, and (with $$n=3f+1$$) there are around $$4.5$$ expected iterations until enough binary consensus instances terminate to pass step 8, i.e., $$18$$ communication rounds. Thus the total number of asynchronous communication rounds for the whole protocol is $$32$$ ($$4$$ seconds with $$250ms$$ ping latencies). In the average/best case with no faulty processes and mild bounded synchrony, all of the ABC instances will terminate after the first round, thus reducing the communication to only $$17$$ (a little over $$2$$ seconds with $$250ms$$ ping latencies), and uses no threshold cryptography.

For comparison, I think HoneyBadger's protocol uses around $$4\cdot(2.6+\log_2(n-f)+2\cdot\log_2(f))$$, which with $$n=31$$ and $$f=10$$ is already over $$54$$ communication rounds, which is nearly $$7$$ seconds with a $$250ms$$ ping latency. By forcing the first consensus iteration to use a common coin whose value is determinstically set to $$1$$, this can easily be improved to $$4\cdot(3.5+2\cdot\log_2(f))$$, but even this uses over $$40$$ communication rounds with $$n=31$$ and $$f=10$$, and still grows logarithmically with $$n$$. Thus for moderately-sized networks, the improvement proposed in this note speeds up the protocol significantly.
