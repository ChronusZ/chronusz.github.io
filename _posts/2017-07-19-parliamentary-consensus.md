---
layout: default
title: "Parliamentary Consensus"
date: 2017-07-19
use_math: true
---

# Parliamentary Consensus

Parliamentary consensus is an overhaul of the current Ripple consensus algorithm. It gives proveable, total fork safety with much weaker overlap requirements, and fully validates a ledger *every round* (!) as long as one is not "split across two networks", i.e., trying to avoid forking with two nodes which can fork with each other. More specifically, if $$t_i$$ is the number of nodes that can fail in $$\mathsf{UNL}_i$$, and $$t_j$$ is the number of nodes that can fail in $$\mathsf{UNL}_j$$, then parliamentary consensus gives total fork safety whenever $$\vert \mathsf{UNL}_i\cap\mathsf{UNL}_j\vert\geqslant t_i+t_j+\min\{t_i,t_j\}+1$$; this is the condition as Ripple validation needs for *immediate safety*, but in the context of parliamentary consensus, it gives *total safety*.

A later note will describe the rigorous protocol; this current note will describe everything somewhat informally to give the reader an idea of how parliamentary consensus works on a general level. Since parliamentary consensus is so different from the current consensus algorithm, jumping straight into the rigorous protocol would likely only be confusing, so it's better to get a feel for the concepts first.

Roughly speaking, the purpose of parliamentary consensus is to decide each round on a **council** which is agreed upon across the network, and then use the proposals of the council members to construct the final ledger. In order to make such a system work though, there are two issues that need to be resolved:

First, one needs to guarantee that all honest nodes receive the same proposals from all the council members (for avoiding forks) and that all honest nodes receive a proposal from every council member (for allowing safe termination). Even if the network is in agreement on the council, if some nodes receive different proposals from the council members (because the council members could be Byzantine) or if some nodes receive proposals but others don't (because the council members could be crashed, or some Byzantine nodes could be refusing to pass along messages), then the final ledgers constructed by two honest nodes could very easily be different. Thus we need some guarantee about the reliability of the council members. Parliamentary consensus gets over this obstacle by using a **reliable broadcast** primitive, which has certain guarantees about message agreement. The council is then decided upon *after* their proposals have already been sent, and *only* after reliable broadcast has guaranteed that all the honest nodes will agree on the proposals.

Second, every node needs to be aware of which nodes can be on the council. We call nodes which are capable of joining the council **candidates**. If one node thinks $$\mathcal{P}_b$$ is a candidate while another node doesn't even know $$\mathcal{P}_b$$ exists, then if $$\mathcal{P}_b$$ actually does join the council for some round, those nodes could immediately fork. For other consensus algorithms that vote on a council (e.g., HoneyBadger, SINTRA, Red Belly, etc.), this is not a problem because there is assumed universal agreement on the participants. In these systems, every node is a candidate, and since every node is known, everyone trivially agrees on the candidates. For parliamentary consensus, this problem requires more careful consideration. Parliamentary consensus solves this problem by running a "ballot construction" protocol in parallel to allow the network to safely come to agreement on the set of candidates. In practice, there is no real need to make updates to the candidate set quick; we shouldn't be rushing to add new candidates, and the only issue in having faulty candidates (either crashed or Byzantine) is that the expected termination time grows logarithmically with the number of candidates, so faulty candidates slow down termination with no benefit to decentralization. Therefore we can afford to be more conservative about safety for the ballot construction protocol than we can for the main consensus protocol.

The benefit in having a consensus algorithm which fully validates a ledger every round cannot be overstated. A serious limitation for every previous validation protocol (Ripple validation, timid validation, *and* conformist validation) is that large changes to a single node's UNL could have disastrous consequences for future-safety. Since parliamentary consensus fully validates a ledger every round, there is no reliance on nodes having the same UNL between rounds. In parliamentary consensus, a node can change its UNL arbitrarily at any given time and safely use its new UNL in the very next round (if multiple instances of parliamentary consensus are running at the same time for whatever reason, then a node still needs to use the same UNL as it did before in all previous instances that have yet to complete, but at the same time it can be using the new UNL in any new instances).

As for its down-sides, the main issue with parliamentary consensus is speed; not only is parliamentary consensus slower than Ripple validation, it could easily be slower than the entire "deliberation" protocol currently in place. I imagine parliamentary consensus could take at least several seconds to terminate, even in complete graphs.

Parliamentary consensus can either be built on top of the current deliberation protocol, or implemented completely on its own. The benefit of building it on top of the deliberation protocol is that one can very effectively run parliamentary consensus and only communicate using transaction set hashes (since most nodes will already be able to recognize most hashes) in order to cut down on network traffic. The benefit of implementing parliamentary consensus totally on its own is that it minimizes the termination time, which is important since parliamentary consensus is slower than Ripple validation; on the other hand, if most transaction sets cannot be recognized by hash alone, this could greatly increase the network traffic, which might nullify any gains in termination speed.
