---
layout: default
title: "Erasure Coded RBC"
date: 2017-08-10
use_math: true
---

# Erasure-Coded Reliable Broadcast Optimization

This note describes a more efficient erasure-coded scheme for doing reliable broadcast in complete graphs. It improves on the communication complexity of the reliable broadcast protocol of HoneyBadger in the worst case by a constant factor of $$2$$ when the broadcaster is honest, and a constant factor of $$18/11$$ when the broadcaster is malicious. For easier comparison, I first recall the reliable broadcast protocol of HoneyBadger before describing the modified protocol.

## HoneyBadger's RBC Protocol

HoneyBadger's reliable broadcast (following the initial suggestion of Cachin and Tessaro, "Asynchronous Verifiable Information Dispersal") improves on the quadratic communication complexity of Bracha's algorithm by a clever use of erasure-coding.

HoneyBadger's protocol can be understood independently of the erasure-coding algorithm, but the understanding the modification requires looking a little bit closer at how erasure-coding actually works. On an abstract level, all erasure-codes involve assigning some data to each node, using that data to construct the blocks, and then giving each node the block that was created using the data assigned to it. For example, Rabin codes encode the message as a polynomial of degree $$n$$, then assigns each node an $$x$$ value, and finally constructs the blocks as the evaluations of the polynomial at the given $$x$$ value. In this case the "data" is the $$x$$ value assigned to each node. For the modified algorithm, this data needs to be publicly known. The easiest way I can think of is to just use the node's public key. Thus for the remainder of this note, when I specify an erasure-coding algorithm, it will be implicit that the data used to construct a node's block is its public key. We also assume that the specific code being used is public, so that any node that knows the full message can re-encrypt the message to construct each individual block deterministically.

HoneyBadger's reliable broadcast algorithm works effectively as follows:

- The broadcaster encrypts its message $$M$$ using an $$(n-2f,n)$$-erasure-code, constructing a block $$s_i$$ for each node $$\mathcal{P}_i$$. It then constructs a Merkle tree over the set $$\{s_i\}$$, and sends the node $$\mathcal{P}_i$$ the message $$INIT(s_i,b_i)$$, where $$b_i$$ is the Merkle branch corresponding to the leaf $$s_i$$.
- When node $$\mathcal{P}_i$$ receives $$INIT(s_i,b_i)$$ from the broadcaster, it verifies the branch and sends $$ECHO(s_i,b_i)$$ to every other node.
- Wait until we've received valid echo messages (i.e., the roots match and the branch is a valid proof) from $$n-2f$$ nodes, then reconstruct the message.
- Wait until we've received valid echo messages from $$n-f$$ nodes, then broadcast $$READY(h)$$, where $$h$$ is the root of the Merkle tree.
- Upon receiving $$f+1$$ valid ready messages, broadcast $$READY(h)$$ if we haven't already.
- Upon receiving $$n-f$$ valid ready messages, wait until we have reconstructed the message if we haven't already. Then accept the message.

This algorithm essentially builds on top of Bracha's algorithm, which by inspection is done explicitly on the root hashes. Therefore the above algorithm immediately respects all the agreement properties of RBC as long as we can prove 1) if the broadcaster is honest, every node is able to reconstruct the original message, and 2) if any honest node accepts reliable broadcast, then every node will eventually be able to reconstruct the original message.

The first property is easy: since there are at least $$n-f$$ honest nodes, and an honest node only needs to receive echoes from $$n-2f$$ honest nodes to be able to reconstruct the message, if the broadcaster is honest and gives every node a valid block, then eventually every honest node will receive enough echoes to reconstruct the original message. The second property follows because the first honest node to ready must have done so because it received $$n-f$$ valid echo messages, of which $$n-2f$$ are guaranteed to be from honest nodes; thus these honest nodes will have also echoed their blocks to every other node, allowing every honest node to eventually reconstruct the original message.

## Modified Protocol

In proving the first property for HoneyBadger's protocol it might have been a little weird that we actually only needed to assume that $$n-2f$$ nodes were honest. In fact, this observation directly leads to the optimization I propose.

The modified protocol works as follows:

- The broadcaster encrypts its message $$M$$ using an $$(n-f,n)$$-erasure-code, constructing a block $$s_i$$ for each node $$\mathcal{P}_i$$. It then constructs a Merkle tree over the set $$\{s_i\}$$, and sends the node $$\mathcal{P}_i$$ the message $$INIT(s_i,b_i)$$, where $$b_i$$ is the Merkle branch corresponding to the leaf $$s_i$$.
- When node $$\mathcal{P}_i$$ receives $$INIT(s_i,b_i)$$ from the broadcaster, it verifies the branch and sends $$ECHO(s_i,b_i)$$ to every other node.
- Wait until we've received valid echo messages (i.e., the roots match and the branch is a valid proof) from $$n-f$$ nodes, then reconstruct the message and broadcast $$READY(h)$$, where $$h$$ is the root of the Merkle tree. At the same time, re-encrypt the message with the same erasure code as above to construct every node's block, and compute the Merkle tree over it. For every node $$\mathcal{P}_j$$ that we *didn't* receive a valid echo from, encrypt $$\{s_j,b_j\}$$ using an $$(n-2f,n)$$-erasure code, construct a Merkle tree over its blocks, and send $$INITRE(s_j',b_j')$$ to $$\mathcal{P}_j$$, where $$s_j'$$ is *our own* block in the encryption of $$s_j$$, and $$b_j'$$ is the branch in the Merkle tree corresponding to $$s_j'$$.
- If we receive $$f+1$$ $$INITRE$$ messages with matching root hashes and valid branches, use them to reconstruct our block $$s_i$$ and the Merkle branch $$b_i$$. If we did not receive an $$INIT$$ message with a root which matches the $$INITRE$$ messages' (or if we didn't receive an $$INIT$$, period), broadcast $$ECHORE(s_i,b_i)$$ to every node from which we did not receive an $$INITRE$$ message.
- If we haven't received enough $$ECHO$$ messages to reconstruct the original message, but we do receive enough combined $$ECHO$$ and $$ECHORE$$ messages to reconstruct the original message, do so and save it in a key-value pair with the relevant root hash, but don't send out a ready message.
- Upon receiving $$f+1$$ valid ready messages for the root $$h$$, wait until we have reconstructed the message with matching root hash. Then, if we haven't already broadcasted a ready message, broadcast $$READY(h)$$ and do the protocol from step $$3$$ for sending out $$INITRE$$ messages to the (at most $$f$$) nodes who we didn't receive either $$ECHO$$ or $$ECHORE$$ messages advocating $$h$$.
- Upon receiving $$n-f$$ valid ready messages for $$h$$, wait until we have reconstructed the message corresponding to $$h$$ if we haven't already. Then accept the message.

Despite the added complexity, it is still easily seen that the above protocol builds on Bracha's algorithm, which runs on the root hashes. Thus we just need to again show that the two properties about message reconstruction hold. The first property is again easy. The use of $$(n-f,n)$$-erasure-codes instead of $$(n-2f,n)$$-codes brings the argument to maximal efficiency, requiring exactly $$n-f$$ honest nodes to work.

The second property is slightly more difficult. If the broadcaster is dishonest, we can't guarantee that every honest node will have received an $$INIT$$ message from it; alternatively, the sender might have sent some of the honest nodes blocks corresponding to one message while sending the other honest nodes blocks corresponding to a different message. The key to notice is that if any honest node accepts the message, then at least $$f+1$$ honest nodes must have readied it, and if $$f+1$$ honest nodes ready the root $$h$$, then every node can reconstruct its own block from the message corresponding to $$h$$: If an honest node didn't receive a block corresponding to the root $$h$$, then every honest node will send it an $$INITRE$$ message, guaranteeing that eventually it will receive $$f+1$$ $$INITRE$$ messages allowing it to construct its own block. Since an honest node only sends out $$INITRE$$ messages if it knows the original message, any honest node that sends out an $$ECHORE$$ message will send it to every honest node that doesn't know the original message. Thus eventually every honest node receives either an $$ECHO$$ or an $$ECHORE$$ message pertaining to $$h$$ from every other honest node, allowing it to reconstruct the original message from the $$(n-f,n)$$ coding.

## Comparing the Communication Costs

We assume that the $$(k,n)$$-erasure-coding algorithm takes a message of size $$M$$ and produces blocks of size $$M/k$$. In practice the erasure-coding usually adds a slight bit of extra size to each block, but for very large messages like we consider, this overhead is negligible. We also assume that $$M\gg n^2\log_2{n}\lambda$$, where $$\lambda$$ is the hash size. Again, for the messages which are relevant this is reasonable, and it helps us write more transparent asymptotic complexities.

The complexity of HoneyBadger's algorithm is simple to compute. It is $$n(n-1)M/(n-2f)+\lambda n(n-1)(1+\log_2{n})$$. The first term comes from echoing the erasure blocks, while the second term comes from echoing the branches and readying the roots. Using $$n=3f+1$$ and simplifying, we get an asymptotic communication complexity of $$3nM$$.

The complexity of the modified algorithm is rather more... complicated to compute. If the sender is honest, it will send $$INIT$$ messages to every node and all using the same root. In this case an honest node will never receive $$INITRE$$ messages for a different root, and so will not send out any $$ECHORE$$ message. Thus the complexity is only $$n(n-1)M/(n-f)+nf(M+\lambda\cdot\log_2{n})/((n-f)(n-2f))+\lambda n(n-1)(1+\log_2{n})$$. The first term comes from echoing the blocks, second term comes from sending $$INITRE$$'s, and the last again comes from echoing branches and readying roots. This leads to an asymptotic complexity of $$3nM/2$$.

Now we consider the case where the sender is dishonest. Note that all $$INITRE$$ messages sent from honest nodes relate to a single root. Indeed, inspection of the protocol shows that honest nodes only send out $$INITRE$$ messages when they ready a root hash, and Bracha's algorithm guarantees that if two honest nodes ready a message, then that message is the same. Since a node only sends out an $$ECHORE$$ message after receiving an $$INITRE$$ message from at least one honest node, all $$ECHORE$$ messages sent by honest nodes will pertain to a single root, and an honest node only sends out an $$ECHORE$$ if it didn't $$ECHO$$ a block for that same message. For the first honest node to ready though, it must have received valid echoes pertaining to that root from at least $$n-f$$ nodes, so at most $$f$$ honest nodes could have *not* received a block for that root. In the worst case these nodes will have echoed a message for a different root. But when a node broadcasts an $$ECHORE$$ message, it only broadcasts its message to at most $$n-f-2$$ nodes (the other nodes from which it did not receive an $$INITRE$$ message). All this leads to having in the worst case every node broadcasting a message of size $$M/(n-f)$$ to every other node, and $$f$$ nodes *also* broadcasting a message of size $$M/(n-f)$$ to $$n-f-2$$ other nodes. From there everything proceeds roughly the same as the honest case, giving an overall asymptotic complexity of $$3nM/2+fM\approx 11nM/6$$.
